#!/usr/bin/env python
# Author:  J Fuentes
# Contact: me@fvnts.ch

"""
    
    Poisson Equation  2D
    DO NOT EDIT THIS FILE
    
    """

# --------------------------------------------------------------------------------/
import os
import time
import numpy as np
from sys import *
from pylab import *
from scipy import *

from numpy import asmatrix as MX
from scipy.sparse import spdiags
# --------------------------------------------------------------------------------/
os.system('cls' if os.name == 'nt' else 'clear')
# --------------------------------------------------------------------------------/
class Timer(object):
    """
        timer class
        example:
        
        with engine.Timer('foo'):
            [do something foo]
        """
    def __init__(self, name=None):
        self.name = name
    
    def __enter__(self):
        self.tstart = time.time()
    
    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        m, s = divmod(time.time() - self.tstart, 60)
        h, m = divmod(m, 60)
        print ' '
        print ' > ELAPSED TIME: %d:%02d:%02d ' % (h, m ,s)
        print ' '
# --------------------------------------------------------------------------------/
def f(x, y):
    """
        KADOMTSEV PETVIASHVILI SOURCE
        """
    mu = nu = 1.0
    p =  -( x + nu*y )**2  + mu**2 * y**2 + mu**(-2)
    q = ( ( x + nu*y )**2  + mu**2 * y**2 + mu**(-2) )**2
    return p/q
# --------------------------------------------------------------------------------/
def mux(P, Q, m):
    """
        map from 2D vector Q into 1D vector P
        """
    for i in range(m):
        r, s = i * m, (i + 1) * m
        P[r:s] = Q[:,i]
# --------------------------------------------------------------------------------/
def demux(P, Q, m):
    """
        map from 1D vector Q into 2D vector P
        """
    for i in range(m):
        r, s = i * m, (i + 1) * m
        P[:,i] = Q[r:s,0].T
# --------------------------------------------------------------------------------/
def method(a, b, m, loops):
    """
        SOR Algorithm 
        serial implementation
        """
    # mesh width
    h = (b - a) / (1.0 + m)
    
    # coordinates
    x = y = np.linspace(a, b, m)
    x , y = meshgrid(x, y)
    
    # structure
    o = np.ones(m)
    A = np.zeros( (m * m, m * m) )

    # blocks
    H = spdiags([o, -4*o, o], [-1, 0, 1], m, m).toarray()
    I = np.identity(m)

    # Toeplitz blocks
    for i in range(m):
        a, b, c = i * m, (i + 1) * m, (i + 2) * m
        A[a:b, a:b] = H
        if i < m - 1:
            A[b:c, a:b] = A[a:b, b:c] = I

    # rescaling Toeplitz matrix
    A = h**(-2) * A

    # fitting the boundaries
    A[0,0], A[0,1], A[-1,-2], A[-1,-1] = 1, 0, 0, 1

    # auxiliary arrays
    F = f(x, y)
    G = np.zeros(m * m)
    U = np.zeros(m * m)[:,None]
    u = np.zeros((m,m))

    # mux
    G = F.T.reshape(-1)
    
    # matrices
    D = np.diag(np.diag(A))
    L = D - np.tril(A)
    U = D - np.triu(A)
    
    # optimal omega
    omega = 2.0 / (1.0 + np.sin(math.pi * h))
    M = omega**(-1) * (D - omega * L)
    N = omega**(-1) * ((1.0 - omega) * D + omega * U)
    
    # iterations
    for i in range(loops):
        # flush out
        done = (i + 1)/(1.0 * loops) * 100.0
        stdout.write(">> CYCLE %d/%d | PROGRESS %.2f %% %s"
                     % (i + 1, loops, done, "\r"))
        stdout.flush()
        # solve linear system
        U = MX(M).I * ( MX(N) * MX(U) - MX(G).T )
    # demultiplexer
    demux(u, U, m)
    # outcomes
    return u, x, y
# --------------------------------------------------------------------------------/
# eof
# --------------------------------------------------------------------------------/
